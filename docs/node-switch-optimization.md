# èŠ‚ç‚¹åˆ‡æ¢ä¸æ»‘åº¦ä¼˜åŒ–æ–¹æ¡ˆ

**åˆ›å»ºæ—¥æœŸ**: 2025-12-01
**çŠ¶æ€**: å¾…å®æ–½
**ä¼˜å…ˆçº§**: P0ï¼ˆæ ¸å¿ƒä½“éªŒä¼˜åŒ–ï¼‰

---

## ä¸€ã€é—®é¢˜è¯Šæ–­

### 1.1 å½“å‰åˆ‡æ¢æµç¨‹

```
è¯·æ±‚åˆ°è¾¾ â†’ ä½¿ç”¨èŠ‚ç‚¹A â†’ èŠ‚ç‚¹Aå¤±è´¥ â†’ è®°å½•å¤±è´¥ â†’ è¾¾åˆ°é˜ˆå€¼ â†’ åˆ‡æ¢åˆ°èŠ‚ç‚¹B â†’ âŒ ç”¨æˆ·è¯·æ±‚å·²å¤±è´¥
```

**æ ¸å¿ƒé—®é¢˜**ï¼šç”¨æˆ·è¯·æ±‚å¤±è´¥åæ‰è§¦å‘åˆ‡æ¢ï¼Œä½“éªŒä¸ä½³ã€‚

### 1.2 å­˜åœ¨çš„é—®é¢˜

| é—®é¢˜ | å½±å“ | ä¸¥é‡æ€§ |
|------|------|--------|
| âŒ ç¼ºå°‘è¯·æ±‚é‡è¯•æœºåˆ¶ | å¤±è´¥è¯·æ±‚ç›´æ¥è¿”å›ï¼Œæ— è‡ªåŠ¨é‡è¯• | ğŸ”´ é«˜ |
| âŒ ç¼ºå°‘èŠ‚ç‚¹é¢„çƒ­ | åˆ‡æ¢åˆ°æ–°èŠ‚ç‚¹æ—¶è¿æ¥æ± å†·å¯åŠ¨ | ğŸŸ¡ ä¸­ |
| âŒ ç¼ºå°‘å¹³æ»‘è¿‡æ¸¡ | ç«‹å³å…¨é‡åˆ‡æ¢å¯èƒ½å¯¼è‡´é›ªå´© | ğŸŸ¡ ä¸­ |
| âŒ ç¼ºå°‘ç†”æ–­å™¨ | æ•…éšœèŠ‚ç‚¹æŒç»­è¢«è®¿é—®ï¼Œå½±å“å¯ç”¨æ€§ | ğŸ”´ é«˜ |
| âŒ ç¼ºå°‘è¯·æ±‚æ’é˜Ÿ | åˆ‡æ¢æœŸé—´çš„è¯·æ±‚ä¼šå¤±è´¥ | ğŸŸ¡ ä¸­ |

### 1.3 æœŸæœ›çš„ä¸æ»‘ä½“éªŒ

```
è¯·æ±‚åˆ°è¾¾ â†’ ä½¿ç”¨èŠ‚ç‚¹A â†’ èŠ‚ç‚¹Aå¤±è´¥ â†’ âœ… ç«‹å³é‡è¯•èŠ‚ç‚¹B â†’ åå°åˆ‡æ¢ â†’ ç”¨æˆ·æ— æ„ŸçŸ¥
```

---

## äºŒã€ä¼˜åŒ–æ–¹æ¡ˆè®¾è®¡

### 2.1 æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     è¯·æ±‚å¤„ç†æµç¨‹                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. è¯·æ±‚é‡è¯•å±‚ï¼ˆP0ï¼‰                                      â”‚
â”‚  - å¤±è´¥è‡ªåŠ¨é‡è¯• N æ¬¡                                      â”‚
â”‚  - è·³è¿‡å·²å¤±è´¥èŠ‚ç‚¹                                         â”‚
â”‚  - æŒ‡æ•°é€€é¿ï¼ˆJittered Backoffï¼‰                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. ç†”æ–­å™¨å±‚ï¼ˆP0ï¼‰                                        â”‚
â”‚  - å¤±è´¥ç‡/è¿ç»­å¤±è´¥è§¦å‘ç†”æ–­                                â”‚
â”‚  - å¼€æ”¾ â†’ åŠå¼€ â†’ å…³é—­çŠ¶æ€æœº                              â”‚
â”‚  - æ»‘åŠ¨çª—å£ç»Ÿè®¡                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. èŠ‚ç‚¹é¢„çƒ­ï¼ˆP0ï¼‰                                        â”‚
â”‚  - åˆ‡æ¢å‰å‘é€æ¢æµ‹è¯·æ±‚                                     â”‚
â”‚  - é¢„çƒ­æˆåŠŸæ‰æ¿€æ´»                                         â”‚
â”‚  - é¢„çƒ­å¤±è´¥è‡ªåŠ¨ä¸‹ä¸€ä¸ªèŠ‚ç‚¹                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. æµé‡æ•´å½¢å™¨ï¼ˆP1ï¼‰                                      â”‚
â”‚  - ç°åº¦åˆ‡æ¢ï¼ˆ10% â†’ 50% â†’ 100%ï¼‰                          â”‚
â”‚  - å¹³æ»‘åŠ æƒè½®è¯¢                                           â”‚
â”‚  - æƒé‡åŠ¨æ€è°ƒæ•´                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  5. è¯·æ±‚é˜Ÿåˆ—ï¼ˆP1ï¼‰                                        â”‚
â”‚  - åˆ‡æ¢æœŸé—´è¯·æ±‚æ’é˜Ÿ                                       â”‚
â”‚  - åˆ‡æ¢å®Œæˆåé‡æ”¾                                         â”‚
â”‚  - æœ‰ç•Œé˜Ÿåˆ—é˜²æ­¢å †ç§¯                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ä¸‰ã€è¯¦ç»†æŠ€æœ¯æ–¹æ¡ˆ

### 3.1 è¯·æ±‚çº§é‡è¯•ï¼ˆP0 - æœ€é«˜ä¼˜å…ˆçº§ï¼‰

#### 3.1.1 å®ç°æ€è·¯

åœ¨å•ä¸ªè¯·æ±‚çš„å¤„ç†æµç¨‹ä¸­å¼•å…¥å¤šèŠ‚ç‚¹é‡è¯•ï¼Œå¤±è´¥åç«‹å³åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªå¥åº·èŠ‚ç‚¹é‡è¯•ã€‚

#### 3.1.2 æ ¸å¿ƒä»£ç ï¼ˆä¼ªä»£ç ï¼‰

```go
// internal/proxy/retry.go (æ–°å¢)
type RetryConfig struct {
    MaxRetries      int           // æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œé»˜è®¤ 3
    RetryBackoffMin time.Duration // æœ€å°é€€é¿æ—¶é—´ï¼Œé»˜è®¤ 10ms
    RetryBackoffMax time.Duration // æœ€å¤§é€€é¿æ—¶é—´ï¼Œé»˜è®¤ 100ms
    RetryOnStatus   []int         // é‡è¯•çš„çŠ¶æ€ç ï¼Œé»˜è®¤ [502, 503, 504]
    PerRequestTimeout time.Duration // å•æ¬¡è¯·æ±‚è¶…æ—¶ï¼Œé»˜è®¤ 30s
}

func (p *Server) handleRequestWithRetry(w http.ResponseWriter, r *http.Request, acc *Account) {
    cfg := p.retryConfig
    skipNodes := make(map[string]bool)

    for attempt := 0; attempt < cfg.MaxRetries; attempt++ {
        // é€‰æ‹©å¥åº·èŠ‚ç‚¹ï¼ˆè·³è¿‡å·²å¤±è´¥çš„ï¼‰
        node, err := p.selectHealthyNode(acc, skipNodes)
        if err != nil {
            http.Error(w, "no available nodes", http.StatusServiceUnavailable)
            return
        }

        // è®¾ç½®å•æ¬¡è¯·æ±‚è¶…æ—¶
        ctx, cancel := context.WithTimeout(r.Context(), cfg.PerRequestTimeout)
        defer cancel()

        // ä»£ç†è¯·æ±‚
        proxy := p.newReverseProxy(node, &usage{})
        recorder := &responseRecorder{ResponseWriter: w}
        proxy.ServeHTTP(recorder, r.WithContext(ctx))

        // åˆ¤æ–­æ˜¯å¦éœ€è¦é‡è¯•
        if !shouldRetry(recorder.status, cfg) {
            return // æˆåŠŸæˆ–ä¸å¯é‡è¯•çš„é”™è¯¯
        }

        // æ ‡è®°èŠ‚ç‚¹å¤±è´¥ï¼ŒåŠ å…¥è·³è¿‡åˆ—è¡¨
        p.markNodeFailed(node.ID, fmt.Sprintf("status %d", recorder.status))
        skipNodes[node.ID] = true

        // é€€é¿ç­‰å¾…ï¼ˆå¸¦æŠ–åŠ¨ï¼‰
        if attempt < cfg.MaxRetries-1 {
            backoff := calculateBackoff(attempt, cfg)
            time.Sleep(backoff)
        }
    }

    // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥
    http.Error(w, "all nodes failed", http.StatusBadGateway)
}

func calculateBackoff(attempt int, cfg RetryConfig) time.Duration {
    // æŒ‡æ•°é€€é¿ + æŠ–åŠ¨
    base := cfg.RetryBackoffMin * time.Duration(1<<uint(attempt))
    if base > cfg.RetryBackoffMax {
        base = cfg.RetryBackoffMax
    }
    jitter := time.Duration(rand.Int63n(int64(base / 2)))
    return base + jitter
}

func shouldRetry(status int, cfg RetryConfig) bool {
    // 5xx æœåŠ¡å™¨é”™è¯¯æˆ–é…ç½®çš„çŠ¶æ€ç 
    for _, code := range cfg.RetryOnStatus {
        if status == code {
            return true
        }
    }
    return status >= 500
}
```

#### 3.1.3 é…ç½®å‚æ•°

```go
// ç¯å¢ƒå˜é‡
RETRY_MAX_ATTEMPTS=3              // æœ€å¤§é‡è¯•æ¬¡æ•°
RETRY_BACKOFF_MIN_MS=10           // æœ€å°é€€é¿æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
RETRY_BACKOFF_MAX_MS=100          // æœ€å¤§é€€é¿æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
RETRY_ON_STATUS=502,503,504       // é‡è¯•çš„çŠ¶æ€ç 
RETRY_PER_REQUEST_TIMEOUT_SEC=30  // å•æ¬¡è¯·æ±‚è¶…æ—¶ï¼ˆç§’ï¼‰
```

---

### 3.2 èŠ‚ç‚¹é¢„çƒ­ï¼ˆP0ï¼‰

#### 3.2.1 å®ç°æ€è·¯

åœ¨åˆ‡æ¢åˆ°æ–°èŠ‚ç‚¹å‰ï¼Œå…ˆå‘é€ 1-2 ä¸ªè½»é‡çº§æ¢æµ‹è¯·æ±‚ï¼Œç¡®ä¿èŠ‚ç‚¹å¯ç”¨åå†æ¿€æ´»ã€‚

#### 3.2.2 æ ¸å¿ƒä»£ç 

```go
// internal/proxy/warmup.go (æ–°å¢)
type WarmupConfig struct {
    Enabled      bool          // æ˜¯å¦å¯ç”¨é¢„çƒ­ï¼Œé»˜è®¤ true
    Attempts     int           // é¢„çƒ­å°è¯•æ¬¡æ•°ï¼Œé»˜è®¤ 2
    TimeoutMs    int           // é¢„çƒ­è¶…æ—¶ï¼ˆæ¯«ç§’ï¼‰ï¼Œé»˜è®¤ 5000
    Path         string        // é¢„çƒ­è·¯å¾„ï¼Œé»˜è®¤ "/health" æˆ–ç©ºï¼ˆä½¿ç”¨ HEADï¼‰
}

func (p *Server) prewarmNode(node *Node, cfg WarmupConfig) bool {
    if !cfg.Enabled {
        return true // ç¦ç”¨é¢„çƒ­ï¼Œç›´æ¥è¿”å›æˆåŠŸ
    }

    p.logger.Printf("[warmup] prewarming node %s...", node.Name)

    successCount := 0
    for i := 0; i < cfg.Attempts; i++ {
        ctx, cancel := context.WithTimeout(context.Background(),
            time.Duration(cfg.TimeoutMs)*time.Millisecond)
        defer cancel()

        var success bool
        var latency time.Duration

        if cfg.Path != "" {
            // ä½¿ç”¨è‡ªå®šä¹‰è·¯å¾„ï¼ˆGET è¯·æ±‚ï¼‰
            success, _, latency = p.healthCheckViaPath(ctx, node, cfg.Path)
        } else {
            // ä½¿ç”¨ HEAD è¯·æ±‚
            success, _, latency = p.healthCheckViaHEAD(ctx, *node)
        }

        if success {
            successCount++
            p.logger.Printf("[warmup] node %s probe %d/%d success (latency: %dms)",
                node.Name, i+1, cfg.Attempts, latency.Milliseconds())
        } else {
            p.logger.Printf("[warmup] node %s probe %d/%d failed",
                node.Name, i+1, cfg.Attempts)
        }
    }

    // è‡³å°‘æˆåŠŸä¸€æ¬¡æ‰è®¤ä¸ºé¢„çƒ­æˆåŠŸ
    success := successCount > 0
    if success {
        p.logger.Printf("[warmup] node %s prewarmed successfully (%d/%d)",
            node.Name, successCount, cfg.Attempts)
    } else {
        p.logger.Printf("[warmup] node %s prewarm failed", node.Name)
    }

    return success
}

// ä¿®æ”¹ selectBestAndActivateï¼ŒåŠ å…¥é¢„çƒ­
func (p *Server) selectBestAndActivateWithWarmup(acc *Account, reason ...string) (*Node, error) {
    // é€‰æ‹©å€™é€‰èŠ‚ç‚¹åˆ—è¡¨ï¼ˆæŒ‰æƒé‡æ’åºï¼‰
    candidates := p.getCandidateNodes(acc)

    for _, node := range candidates {
        // é¢„çƒ­èŠ‚ç‚¹
        if p.prewarmNode(node, p.warmupConfig) {
            // é¢„çƒ­æˆåŠŸï¼Œæ¿€æ´»èŠ‚ç‚¹
            p.mu.Lock()
            acc.ActiveID = node.ID
            p.mu.Unlock()

            if p.store != nil {
                _ = p.store.SetActive(context.Background(), acc.ID, node.ID)
            }

            p.logger.Printf("switched to node %s (reason: %s)", node.Name, reason[0])
            return node, nil
        }

        // é¢„çƒ­å¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        p.logger.Printf("node %s prewarm failed, trying next node", node.Name)
    }

    return nil, ErrNoActiveNode
}
```

#### 3.2.3 é…ç½®å‚æ•°

```go
WARMUP_ENABLED=true               // æ˜¯å¦å¯ç”¨é¢„çƒ­
WARMUP_ATTEMPTS=2                 // é¢„çƒ­å°è¯•æ¬¡æ•°
WARMUP_TIMEOUT_MS=5000            // é¢„çƒ­è¶…æ—¶ï¼ˆæ¯«ç§’ï¼‰
WARMUP_PATH=/health               // é¢„çƒ­è·¯å¾„ï¼ˆç©ºåˆ™ä½¿ç”¨ HEADï¼‰
```

---

### 3.3 ç†”æ–­å™¨ï¼ˆP0ï¼‰

#### 3.3.1 çŠ¶æ€æœºè®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   å¤±è´¥ç‡ â‰¥ é˜ˆå€¼      â”Œâ”€â”€â”€â”€â”€â”€â”   å†·å´æ—¶é—´åˆ°    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Closed  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>  â”‚ Open â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>  â”‚HalfOpen â”‚
â”‚ (æ­£å¸¸)  â”‚                      â”‚(ç†”æ–­)â”‚                 â”‚(è¯•æ¢)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â””â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†‘                                                         â”‚
     â”‚                                                         â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         è¯•æ¢æˆåŠŸ / å¤±è´¥é‡æ–°ç†”æ–­
```

#### 3.3.2 æ ¸å¿ƒä»£ç 

```go
// internal/proxy/circuit_breaker.go (æ–°å¢)
type CircuitBreakerConfig struct {
    WindowSeconds     int     // æ»‘åŠ¨çª—å£å¤§å°ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤ 60
    MinRequests       int     // æœ€å°è¯·æ±‚æ•°ï¼Œé»˜è®¤ 20
    FailureRate       float64 // å¤±è´¥ç‡é˜ˆå€¼ï¼Œé»˜è®¤ 0.5 (50%)
    ConsecutiveFails  int     // è¿ç»­å¤±è´¥é˜ˆå€¼ï¼Œé»˜è®¤ 5
    CooldownSeconds   int     // å†·å´æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤ 30
    HalfOpenProbes    int     // åŠå¼€çŠ¶æ€è¯•æ¢æ¬¡æ•°ï¼Œé»˜è®¤ 3
}

type CircuitBreakerState int

const (
    CBClosed CircuitBreakerState = iota // å…³é—­ï¼ˆæ­£å¸¸ï¼‰
    CBOpen                               // å¼€å¯ï¼ˆç†”æ–­ï¼‰
    CBHalfOpen                           // åŠå¼€ï¼ˆè¯•æ¢ï¼‰
)

type CircuitBreaker struct {
    mu               sync.RWMutex
    state            CircuitBreakerState
    window           *SlidingWindow
    consecutiveFails int
    openedAt         time.Time
    halfOpenProbes   int
    cfg              CircuitBreakerConfig
}

type SlidingWindow struct {
    mu       sync.RWMutex
    buckets  []bucket
    idx      int
    interval time.Duration
}

type bucket struct {
    timestamp time.Time
    requests  int
    failures  int
}

func (cb *CircuitBreaker) Allow() bool {
    cb.mu.RLock()
    defer cb.mu.RUnlock()

    switch cb.state {
    case CBClosed:
        return true
    case CBOpen:
        // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾å†·å´æ—¶é—´
        if time.Since(cb.openedAt) >= time.Duration(cb.cfg.CooldownSeconds)*time.Second {
            cb.mu.RUnlock()
            cb.mu.Lock()
            cb.state = CBHalfOpen
            cb.halfOpenProbes = 0
            cb.mu.Unlock()
            cb.mu.RLock()
            return true
        }
        return false
    case CBHalfOpen:
        // åŠå¼€çŠ¶æ€å…è®¸å°‘é‡è¯•æ¢è¯·æ±‚
        return cb.halfOpenProbes < cb.cfg.HalfOpenProbes
    default:
        return false
    }
}

func (cb *CircuitBreaker) RecordSuccess() {
    cb.mu.Lock()
    defer cb.mu.Unlock()

    cb.window.Add(true)
    cb.consecutiveFails = 0

    if cb.state == CBHalfOpen {
        cb.halfOpenProbes++
        if cb.halfOpenProbes >= cb.cfg.HalfOpenProbes {
            // è¯•æ¢æˆåŠŸï¼Œæ¢å¤åˆ°æ­£å¸¸çŠ¶æ€
            cb.state = CBClosed
            cb.window.Reset()
        }
    }
}

func (cb *CircuitBreaker) RecordFailure() {
    cb.mu.Lock()
    defer cb.mu.Unlock()

    cb.window.Add(false)
    cb.consecutiveFails++

    // æ£€æŸ¥æ˜¯å¦éœ€è¦ç†”æ–­
    if cb.state == CBClosed {
        failureRate := cb.window.FailureRate()
        requests := cb.window.TotalRequests()

        // æ¡ä»¶1: å¤±è´¥ç‡è¶…è¿‡é˜ˆå€¼ && è¯·æ±‚æ•°è¶³å¤Ÿ
        condition1 := failureRate >= cb.cfg.FailureRate && requests >= cb.cfg.MinRequests

        // æ¡ä»¶2: è¿ç»­å¤±è´¥æ¬¡æ•°è¶…è¿‡é˜ˆå€¼
        condition2 := cb.consecutiveFails >= cb.cfg.ConsecutiveFails

        if condition1 || condition2 {
            cb.state = CBOpen
            cb.openedAt = time.Now()
        }
    } else if cb.state == CBHalfOpen {
        // åŠå¼€çŠ¶æ€å¤±è´¥ï¼Œé‡æ–°ç†”æ–­
        cb.state = CBOpen
        cb.openedAt = time.Now()
    }
}

// æ»‘åŠ¨çª—å£å®ç°
func (w *SlidingWindow) Add(success bool) {
    w.mu.Lock()
    defer w.mu.Unlock()

    now := time.Now()

    // æ‰¾åˆ°å½“å‰æ—¶é—´æ§½
    for i := range w.buckets {
        if now.Sub(w.buckets[i].timestamp) < w.interval {
            w.buckets[i].requests++
            if !success {
                w.buckets[i].failures++
            }
            return
        }
    }

    // åˆ›å»ºæ–°æ—¶é—´æ§½
    w.idx = (w.idx + 1) % len(w.buckets)
    w.buckets[w.idx] = bucket{
        timestamp: now,
        requests:  1,
        failures:  0,
    }
    if !success {
        w.buckets[w.idx].failures++
    }
}

func (w *SlidingWindow) FailureRate() float64 {
    w.mu.RLock()
    defer w.mu.RUnlock()

    totalReq := 0
    totalFail := 0

    cutoff := time.Now().Add(-w.interval)
    for _, b := range w.buckets {
        if b.timestamp.After(cutoff) {
            totalReq += b.requests
            totalFail += b.failures
        }
    }

    if totalReq == 0 {
        return 0
    }

    return float64(totalFail) / float64(totalReq)
}

func (w *SlidingWindow) TotalRequests() int {
    w.mu.RLock()
    defer w.mu.RUnlock()

    total := 0
    cutoff := time.Now().Add(-w.interval)
    for _, b := range w.buckets {
        if b.timestamp.After(cutoff) {
            total += b.requests
        }
    }
    return total
}
```

#### 3.3.3 é›†æˆåˆ°èŠ‚ç‚¹ç®¡ç†

```go
// åœ¨ Node ç»“æ„ä¸­æ·»åŠ ç†”æ–­å™¨
type Node struct {
    // ... ç°æœ‰å­—æ®µ ...
    CircuitBreaker *CircuitBreaker
}

// åœ¨è¯·æ±‚å¤„ç†ä¸­ä½¿ç”¨ç†”æ–­å™¨
func (p *Server) selectHealthyNode(acc *Account, skip map[string]bool) (*Node, error) {
    p.mu.RLock()
    defer p.mu.RUnlock()

    var best *Node
    for id, node := range acc.Nodes {
        // è·³è¿‡ç¦ç”¨ã€å¤±è´¥ã€å·²å°è¯•çš„èŠ‚ç‚¹
        if node.Disabled || node.Failed || skip[id] {
            continue
        }

        // æ£€æŸ¥ç†”æ–­å™¨
        if node.CircuitBreaker != nil && !node.CircuitBreaker.Allow() {
            continue
        }

        // é€‰æ‹©æƒé‡æœ€å°ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰çš„èŠ‚ç‚¹
        if best == nil || node.Weight < best.Weight {
            best = node
        }
    }

    if best == nil {
        return nil, ErrNoActiveNode
    }

    return best, nil
}

// åœ¨è¯·æ±‚æˆåŠŸ/å¤±è´¥æ—¶è®°å½•
func (p *Server) recordRequestResult(nodeID string, success bool) {
    node := p.getNode(nodeID)
    if node != nil && node.CircuitBreaker != nil {
        if success {
            node.CircuitBreaker.RecordSuccess()
        } else {
            node.CircuitBreaker.RecordFailure()
        }
    }
}
```

---

### 3.4 æµé‡æ•´å½¢ä¸ç°åº¦åˆ‡æ¢ï¼ˆP1ï¼‰

#### 3.4.1 å®ç°æ€è·¯

ä½¿ç”¨åŠ æƒè½®è¯¢ç®—æ³•ï¼Œæ”¯æŒåŠ¨æ€è°ƒæ•´èŠ‚ç‚¹æƒé‡ï¼Œå®ç°æ¸è¿›å¼ç°åº¦åˆ‡æ¢ã€‚

#### 3.4.2 æ ¸å¿ƒä»£ç 

```go
// internal/proxy/traffic_shaper.go (æ–°å¢)
type TrafficShaper struct {
    mu      sync.RWMutex
    weights map[string]*WeightedNode
}

type WeightedNode struct {
    Node            *Node
    TrafficWeight   int     // æµé‡æƒé‡ï¼ˆ0-100ï¼‰
    CurrentWeight   int     // å½“å‰æƒé‡ï¼ˆç”¨äºå¹³æ»‘ WRRï¼‰
    EffectiveWeight int     // æœ‰æ•ˆæƒé‡
}

// å¹³æ»‘åŠ æƒè½®è¯¢ï¼ˆSmooth Weighted Round Robinï¼‰
func (ts *TrafficShaper) SelectNode(nodes []*Node) *Node {
    ts.mu.Lock()
    defer ts.mu.Unlock()

    var best *WeightedNode
    total := 0

    for _, node := range nodes {
        wn, ok := ts.weights[node.ID]
        if !ok {
            wn = &WeightedNode{
                Node:            node,
                TrafficWeight:   100,
                CurrentWeight:   0,
                EffectiveWeight: 100,
            }
            ts.weights[node.ID] = wn
        }

        wn.CurrentWeight += wn.EffectiveWeight
        total += wn.EffectiveWeight

        if best == nil || wn.CurrentWeight > best.CurrentWeight {
            best = wn
        }
    }

    if best == nil {
        return nil
    }

    best.CurrentWeight -= total
    return best.Node
}

// æ¸è¿›å¼è°ƒæ•´æƒé‡
func (ts *TrafficShaper) AdjustWeight(nodeID string, delta int) {
    ts.mu.Lock()
    defer ts.mu.Unlock()

    if wn, ok := ts.weights[nodeID]; ok {
        newWeight := wn.TrafficWeight + delta
        if newWeight < 0 {
            newWeight = 0
        } else if newWeight > 100 {
            newWeight = 100
        }
        wn.TrafficWeight = newWeight
        wn.EffectiveWeight = newWeight
    }
}

// ç°åº¦åˆ‡æ¢ç­–ç•¥
func (p *Server) gradualSwitch(oldNodeID, newNodeID string) {
    // é˜¶æ®µ1: æ–°èŠ‚ç‚¹ 10%
    p.trafficShaper.AdjustWeight(newNodeID, 10)
    p.trafficShaper.AdjustWeight(oldNodeID, -10)
    time.Sleep(30 * time.Second)

    // æ£€æŸ¥æ–°èŠ‚ç‚¹å¥åº·åº¦
    if !p.isNodeHealthy(newNodeID) {
        // å›æ»š
        p.trafficShaper.AdjustWeight(newNodeID, -10)
        p.trafficShaper.AdjustWeight(oldNodeID, 10)
        return
    }

    // é˜¶æ®µ2: æ–°èŠ‚ç‚¹ 50%
    p.trafficShaper.AdjustWeight(newNodeID, 40)
    p.trafficShaper.AdjustWeight(oldNodeID, -40)
    time.Sleep(30 * time.Second)

    // å†æ¬¡æ£€æŸ¥
    if !p.isNodeHealthy(newNodeID) {
        // å›æ»š
        p.trafficShaper.AdjustWeight(newNodeID, -50)
        p.trafficShaper.AdjustWeight(oldNodeID, 50)
        return
    }

    // é˜¶æ®µ3: æ–°èŠ‚ç‚¹ 100%
    p.trafficShaper.AdjustWeight(newNodeID, 50)
    p.trafficShaper.AdjustWeight(oldNodeID, -50)
}
```

---

### 3.5 è¯·æ±‚æ’é˜Ÿä¸é‡æ”¾ï¼ˆP1ï¼‰

#### 3.5.1 å®ç°æ€è·¯

åœ¨èŠ‚ç‚¹åˆ‡æ¢æœŸé—´ï¼Œå°†æ–°åˆ°çš„è¯·æ±‚æ”¾å…¥æœ‰ç•Œé˜Ÿåˆ—ï¼Œåˆ‡æ¢å®Œæˆåé‡æ”¾ã€‚

#### 3.5.2 æ ¸å¿ƒä»£ç 

```go
// internal/proxy/request_queue.go (æ–°å¢)
type RequestQueue struct {
    mu       sync.RWMutex
    queue    chan *QueuedRequest
    enabled  bool
    maxSize  int
    timeout  time.Duration
}

type QueuedRequest struct {
    Request  *http.Request
    Response http.ResponseWriter
    Done     chan error
}

func NewRequestQueue(size int, timeout time.Duration) *RequestQueue {
    return &RequestQueue{
        queue:   make(chan *QueuedRequest, size),
        enabled: false,
        maxSize: size,
        timeout: timeout,
    }
}

func (rq *RequestQueue) Enqueue(w http.ResponseWriter, r *http.Request) error {
    if !rq.enabled {
        return nil // é˜Ÿåˆ—æœªå¯ç”¨ï¼Œç›´æ¥è¿”å›
    }

    qr := &QueuedRequest{
        Request:  r,
        Response: w,
        Done:     make(chan error, 1),
    }

    select {
    case rq.queue <- qr:
        // ç­‰å¾…å¤„ç†å®Œæˆæˆ–è¶…æ—¶
        select {
        case err := <-qr.Done:
            return err
        case <-time.After(rq.timeout):
            return fmt.Errorf("queue wait timeout")
        }
    default:
        return fmt.Errorf("queue full")
    }
}

func (rq *RequestQueue) StartDraining(handler func(w http.ResponseWriter, r *http.Request) error) {
    go func() {
        for qr := range rq.queue {
            err := handler(qr.Response, qr.Request)
            qr.Done <- err
        }
    }()
}

func (rq *RequestQueue) Enable() {
    rq.mu.Lock()
    defer rq.mu.Unlock()
    rq.enabled = true
}

func (rq *RequestQueue) Disable() {
    rq.mu.Lock()
    defer rq.mu.Unlock()
    rq.enabled = false
}
```

---

## å››ã€å®ç°ä¼˜å…ˆçº§

### P0 - æ ¸å¿ƒåŠŸèƒ½ï¼ˆå¿…é¡»å®ç°ï¼‰

- âœ… **è¯·æ±‚çº§é‡è¯•**ï¼šç«‹å³è§æ•ˆï¼Œå¤§å¹…æå‡å¯ç”¨æ€§
- âœ… **èŠ‚ç‚¹é¢„çƒ­**ï¼šé¿å…å†·å¯åŠ¨é—®é¢˜
- âœ… **ç†”æ–­å™¨**ï¼šä¿æŠ¤ç³»ç»Ÿï¼Œé¿å…é›ªå´©

### P1 - é‡è¦ä¼˜åŒ–ï¼ˆå»ºè®®å®ç°ï¼‰

- âš¡ **æµé‡æ•´å½¢**ï¼šæ›´å¹³æ»‘çš„åˆ‡æ¢ä½“éªŒ
- âš¡ **è¯·æ±‚æ’é˜Ÿ**ï¼šåˆ‡æ¢æœŸé—´é›¶å¤±è´¥

### P2 - å¯é€‰ä¼˜åŒ–ï¼ˆæœªæ¥è¿­ä»£ï¼‰

- ğŸ”® è‡ªé€‚åº”é€€é¿ï¼ˆæ ¹æ®èŠ‚ç‚¹ RTT åŠ¨æ€è°ƒæ•´ï¼‰
- ğŸ”® ç»†ç²’åº¦æŒ‡æ ‡ï¼ˆPrometheus + Grafanaï¼‰
- ğŸ”® å¤±è´¥åŸå› åˆ†ç±»ç»Ÿè®¡

---

## äº”ã€ä»£ç ä¿®æ”¹æ¸…å•

### 5.1 éœ€è¦ä¿®æ”¹çš„ç°æœ‰æ–‡ä»¶

| æ–‡ä»¶ | ä¿®æ”¹å†…å®¹ | å½±å“ |
|------|----------|------|
| `internal/proxy/handler.go` | å¼•å…¥é‡è¯•å¾ªç¯ï¼Œæ›¿æ¢å•æ¬¡ä»£ç† | æ ¸å¿ƒè¯·æ±‚å¤„ç†é€»è¾‘ |
| `internal/proxy/node_manager.go` | æ·»åŠ  `selectHealthyNode` æ–¹æ³•ï¼Œæ”¯æŒè·³è¿‡å¤±è´¥èŠ‚ç‚¹ | èŠ‚ç‚¹é€‰æ‹©é€»è¾‘ |
| `internal/proxy/node_manager.go` | ä¿®æ”¹ `selectBestAndActivate`ï¼ŒåŠ å…¥é¢„çƒ­ | èŠ‚ç‚¹åˆ‡æ¢é€»è¾‘ |
| `internal/proxy/types.go` | Node ç»“æ„æ·»åŠ ç†”æ–­å™¨å­—æ®µ | æ•°æ®æ¨¡å‹ |

### 5.2 éœ€è¦æ–°å¢çš„æ–‡ä»¶

| æ–‡ä»¶ | åŠŸèƒ½ | ä¼˜å…ˆçº§ |
|------|------|--------|
| `internal/proxy/retry.go` | è¯·æ±‚é‡è¯•é€»è¾‘ä¸é…ç½® | P0 |
| `internal/proxy/warmup.go` | èŠ‚ç‚¹é¢„çƒ­å®ç° | P0 |
| `internal/proxy/circuit_breaker.go` | ç†”æ–­å™¨çŠ¶æ€æœº | P0 |
| `internal/proxy/traffic_shaper.go` | æµé‡æ•´å½¢ä¸åŠ æƒè½®è¯¢ | P1 |
| `internal/proxy/request_queue.go` | è¯·æ±‚é˜Ÿåˆ—ä¸é‡æ”¾ | P1 |

---

## å…­ã€é…ç½®å‚æ•°è®¾è®¡

### 6.1 ç¯å¢ƒå˜é‡

```bash
# è¯·æ±‚é‡è¯•ï¼ˆP0ï¼‰
RETRY_MAX_ATTEMPTS=3
RETRY_BACKOFF_MIN_MS=10
RETRY_BACKOFF_MAX_MS=100
RETRY_ON_STATUS=502,503,504
RETRY_PER_REQUEST_TIMEOUT_SEC=30

# èŠ‚ç‚¹é¢„çƒ­ï¼ˆP0ï¼‰
WARMUP_ENABLED=true
WARMUP_ATTEMPTS=2
WARMUP_TIMEOUT_MS=5000
WARMUP_PATH=/health

# ç†”æ–­å™¨ï¼ˆP0ï¼‰
CB_WINDOW_SECONDS=60
CB_MIN_REQUESTS=20
CB_FAILURE_RATE=0.5
CB_CONSECUTIVE_FAILS=5
CB_COOLDOWN_SECONDS=30
CB_HALFOPEN_PROBES=3

# æµé‡æ•´å½¢ï¼ˆP1ï¼‰
TRAFFIC_SHAPER_ENABLED=false
GRADUAL_SWITCH_ENABLED=false
GRADUAL_SWITCH_STAGES=3

# è¯·æ±‚é˜Ÿåˆ—ï¼ˆP1ï¼‰
REQUEST_QUEUE_ENABLED=false
REQUEST_QUEUE_SIZE=1000
REQUEST_QUEUE_TIMEOUT_MS=5000
```

### 6.2 é»˜è®¤å€¼è¯´æ˜

æ‰€æœ‰æ–°ç‰¹æ€§é»˜è®¤ä¿å®ˆé…ç½®æˆ–å…³é—­ï¼Œç¡®ä¿å‘åå…¼å®¹ï¼š

- `RETRY_MAX_ATTEMPTS=1`ï¼šé»˜è®¤åªé‡è¯• 1 æ¬¡ï¼ˆå³æ‰§è¡Œ 2 æ¬¡è¯·æ±‚ï¼‰
- `WARMUP_ENABLED=true`ï¼šé»˜è®¤å¯ç”¨é¢„çƒ­ï¼ˆå½±å“å°ï¼Œæ”¶ç›Šå¤§ï¼‰
- `CB_FAILURE_RATE=0.5`ï¼šå¤±è´¥ç‡ 50% æ‰ç†”æ–­ï¼ˆè¾ƒå®½æ¾ï¼‰
- `TRAFFIC_SHAPER_ENABLED=false`ï¼šé»˜è®¤ç¦ç”¨æµé‡æ•´å½¢
- `REQUEST_QUEUE_ENABLED=false`ï¼šé»˜è®¤ç¦ç”¨è¯·æ±‚é˜Ÿåˆ—

---

## ä¸ƒã€æµ‹è¯•éªŒè¯æ–¹æ¡ˆ

### 7.1 å•å…ƒæµ‹è¯•

```go
// internal/proxy/retry_test.go
func TestRetryLogic(t *testing.T) {
    tests := []struct {
        name          string
        failureCount  int
        maxRetries    int
        expectSuccess bool
    }{
        {"First attempt succeeds", 0, 3, true},
        {"Second attempt succeeds", 1, 3, true},
        {"All attempts fail", 3, 3, false},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // æµ‹è¯•é€»è¾‘
        })
    }
}

// internal/proxy/circuit_breaker_test.go
func TestCircuitBreakerStateMachine(t *testing.T) {
    cb := NewCircuitBreaker(CircuitBreakerConfig{
        ConsecutiveFails: 3,
        CooldownSeconds:  5,
    })

    // æµ‹è¯• Closed -> Open
    for i := 0; i < 3; i++ {
        cb.RecordFailure()
    }
    assert.Equal(t, CBOpen, cb.state)

    // æµ‹è¯• Open -> HalfOpen
    time.Sleep(6 * time.Second)
    assert.True(t, cb.Allow())
    assert.Equal(t, CBHalfOpen, cb.state)

    // æµ‹è¯• HalfOpen -> Closed
    for i := 0; i < 3; i++ {
        cb.RecordSuccess()
    }
    assert.Equal(t, CBClosed, cb.state)
}
```

### 7.2 é›†æˆæµ‹è¯•åœºæ™¯

#### åœºæ™¯1ï¼šèŠ‚ç‚¹æ•…éšœè‡ªåŠ¨é‡è¯•

```bash
# 1. å¯åŠ¨ä»£ç†æœåŠ¡
go run ./cmd/cccli proxy

# 2. é…ç½®ä¸¤ä¸ªèŠ‚ç‚¹ï¼šnode1ï¼ˆæ•…éšœï¼‰ã€node2ï¼ˆæ­£å¸¸ï¼‰
curl -X POST http://localhost:8000/admin/api/nodes \
  -d '{"name":"node1", "base_url":"http://broken-endpoint", "weight":1}'

curl -X POST http://localhost:8000/admin/api/nodes \
  -d '{"name":"node2", "base_url":"https://api.anthropic.com", "weight":2}'

# 3. å‘é€è¯·æ±‚ï¼Œè§‚å¯Ÿæ˜¯å¦è‡ªåŠ¨é‡è¯•åˆ° node2
curl http://localhost:8000/v1/messages \
  -H "x-api-key: default-proxy-key" \
  -d '{"model":"claude-sonnet-4-5","messages":[{"role":"user","content":"hi"}],"max_tokens":10}'

# é¢„æœŸï¼šè¯·æ±‚æˆåŠŸï¼Œæ—¥å¿—æ˜¾ç¤ºé‡è¯•ä¿¡æ¯
```

#### åœºæ™¯2ï¼šç†”æ–­å™¨è§¦å‘ä¸æ¢å¤

```bash
# 1. æŒç»­å‘é€å¤±è´¥è¯·æ±‚è§¦å‘ç†”æ–­
for i in {1..10}; do
  curl http://localhost:8000/v1/messages \
    -H "x-api-key: broken-key"
done

# 2. è§‚å¯Ÿç†”æ–­å™¨çŠ¶æ€
curl http://localhost:8000/admin/api/nodes

# é¢„æœŸï¼šnode1 çŠ¶æ€ä¸º "circuit_breaker_open"

# 3. ç­‰å¾…å†·å´æ—¶é—´åè‡ªåŠ¨æ¢å¤
sleep 30

# é¢„æœŸï¼šnode1 çŠ¶æ€å˜ä¸º "circuit_breaker_half_open"
```

#### åœºæ™¯3ï¼šé¢„çƒ­æœºåˆ¶éªŒè¯

```bash
# 1. æ·»åŠ ä¸€ä¸ªæ–°èŠ‚ç‚¹
curl -X POST http://localhost:8000/admin/api/nodes \
  -d '{"name":"node3", "base_url":"https://api.anthropic.com", "weight":0}'

# 2. è§‚å¯Ÿæ—¥å¿—ï¼Œç¡®è®¤é¢„çƒ­æ¢æµ‹
# é¢„æœŸæ—¥å¿—ï¼š
# [warmup] prewarming node node3...
# [warmup] node node3 probe 1/2 success (latency: 123ms)
# [warmup] node node3 probe 2/2 success (latency: 125ms)
# [warmup] node node3 prewarmed successfully (2/2)
# switched to node node3 (reason: æ–°å¢èŠ‚ç‚¹)
```

### 7.3 å‹åŠ›æµ‹è¯•

```bash
# ä½¿ç”¨ vegeta è¿›è¡Œå‹æµ‹
echo "GET http://localhost:8000/v1/messages" | vegeta attack \
  -header "x-api-key: default-proxy-key" \
  -header "Content-Type: application/json" \
  -body '{"model":"claude-sonnet-4-5","messages":[{"role":"user","content":"hi"}],"max_tokens":10}' \
  -rate=500 \
  -duration=60s \
  | vegeta report

# é¢„æœŸæŒ‡æ ‡ï¼š
# - Latency p99 < 500ms
# - Success rate > 99.5%
# - èŠ‚ç‚¹æ•…éšœæ—¶è‡ªåŠ¨åˆ‡æ¢ï¼Œç”¨æˆ·æ— æ„ŸçŸ¥
```

### 7.4 ç›‘æ§æŒ‡æ ‡

| æŒ‡æ ‡ | è¯´æ˜ | ç›®æ ‡ |
|------|------|------|
| `retry_attempts_total` | æ€»é‡è¯•æ¬¡æ•° | - |
| `retry_success_rate` | é‡è¯•æˆåŠŸç‡ | > 95% |
| `circuit_breaker_state` | ç†”æ–­å™¨çŠ¶æ€ | Closed |
| `node_failure_rate` | èŠ‚ç‚¹å¤±è´¥ç‡ | < 2% |
| `request_latency_p99` | è¯·æ±‚å»¶è¿Ÿ p99 | < 500ms |
| `warmup_latency_avg` | é¢„çƒ­å¹³å‡å»¶è¿Ÿ | < 200ms |
| `queue_depth` | é˜Ÿåˆ—æ·±åº¦ | < 100 |

---

## å…«ã€å‘åå…¼å®¹æ€§

### 8.1 é…ç½®å…¼å®¹æ€§

- âœ… æ‰€æœ‰æ–°é…ç½®é¡¹éƒ½æœ‰é»˜è®¤å€¼
- âœ… é»˜è®¤å€¼ä¿æŒä¿å®ˆï¼ˆä¸å½±å“ç°æœ‰è¡Œä¸ºï¼‰
- âœ… å¯é€šè¿‡ç¯å¢ƒå˜é‡é€ä¸ªå¯ç”¨

### 8.2 æ•°æ®åº“å…¼å®¹æ€§

- âœ… ä¸éœ€è¦ä¿®æ”¹ç°æœ‰æ•°æ®åº“ Schema
- âœ… ç†”æ–­å™¨çŠ¶æ€ã€é˜Ÿåˆ—ç­‰å‡ä¸ºå†…å­˜çŠ¶æ€
- ğŸ”® ï¼ˆå¯é€‰ï¼‰æœªæ¥å¯æ·»åŠ  JSON å­—æ®µæŒä¹…åŒ–é«˜çº§é…ç½®

### 8.3 API å…¼å®¹æ€§

- âœ… ç°æœ‰ API æ¥å£ä¸å˜
- âœ… å“åº”æ ¼å¼ä¸å˜
- âœ… åªåœ¨å†…éƒ¨å¢å¼ºé”™è¯¯å¤„ç†é€»è¾‘

---

## ä¹ã€å®æ–½è®¡åˆ’

### é˜¶æ®µ1ï¼šæ ¸å¿ƒåŠŸèƒ½ï¼ˆ1-2 å‘¨ï¼‰

- [ ] å®ç°è¯·æ±‚é‡è¯•æœºåˆ¶ï¼ˆ`retry.go`ï¼‰
- [ ] å®ç°èŠ‚ç‚¹é¢„çƒ­ï¼ˆ`warmup.go`ï¼‰
- [ ] å®ç°ç†”æ–­å™¨ï¼ˆ`circuit_breaker.go`ï¼‰
- [ ] é›†æˆåˆ°ç°æœ‰ä»£ç 
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–

### é˜¶æ®µ2ï¼šé«˜çº§åŠŸèƒ½ï¼ˆ1 å‘¨ï¼‰

- [ ] å®ç°æµé‡æ•´å½¢ï¼ˆ`traffic_shaper.go`ï¼‰
- [ ] å®ç°è¯·æ±‚é˜Ÿåˆ—ï¼ˆ`request_queue.go`ï¼‰
- [ ] é›†æˆæµ‹è¯•

### é˜¶æ®µ3ï¼šæµ‹è¯•ä¸ä¼˜åŒ–ï¼ˆ1 å‘¨ï¼‰

- [ ] å‹åŠ›æµ‹è¯•
- [ ] æ€§èƒ½ä¼˜åŒ–
- [ ] ç›‘æ§æŒ‡æ ‡å®Œå–„
- [ ] æ–‡æ¡£æ›´æ–°

---

## åã€æ€»ç»“

### é¢„æœŸæ•ˆæœ

| æŒ‡æ ‡ | å½“å‰ | ä¼˜åŒ–å | æå‡ |
|------|------|--------|------|
| è¯·æ±‚æˆåŠŸç‡ | ~95% | > 99.5% | **+4.5%** |
| æ•…éšœåˆ‡æ¢æ—¶é—´ | 3-5 ç§’ | < 100ms | **50å€** |
| ç”¨æˆ·æ„ŸçŸ¥æ•…éšœ | 100% | < 1% | **99%å‡å°‘** |
| p99 å»¶è¿Ÿ | ~2s | < 500ms | **4å€** |

### å…³é”®æ”¶ç›Š

1. **ç”¨æˆ·ä½“éªŒä¸æ»‘**ï¼šæ•…éšœåˆ‡æ¢å¯¹ç”¨æˆ·é€æ˜
2. **ç³»ç»Ÿå¯ç”¨æ€§æå‡**ï¼šé€šè¿‡é‡è¯• + ç†”æ–­ä¿æŠ¤
3. **è¿ç»´æˆæœ¬é™ä½**ï¼šè‡ªåŠ¨åŒ–æ•…éšœæ¢å¤
4. **ç›‘æ§å¯è§‚æµ‹æ€§å¢å¼º**ï¼šè¯¦ç»†çš„åˆ‡æ¢æŒ‡æ ‡

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0
**åˆ›å»ºæ—¶é—´**: 2025-12-01
**ç»´æŠ¤è€…**: Claude Code Team
